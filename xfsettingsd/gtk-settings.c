/*
 *  Copyright (c) 2023 GaÃ«l Bonithon <gael@xfce.org>
 *
 *  This program is free software; you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation; either version 2 of the License, or
 *  (at your option) any later version.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU Library General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License along
 *  with this program; if not, write to the Free Software Foundation, Inc.,
 *  51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
 */

#ifdef HAVE_CONFIG_H
#include <config.h>
#endif

#include <gio/gio.h>
#include <gtk/gtk.h>
#include <xfconf/xfconf.h>
#include <libxfce4util/libxfce4util.h>

#include "gtk-settings.h"
#include "xsettings-properties.h"



static void         xfce_gtk_settings_helper_finalize                      (GObject               *object);
static void         xfce_gtk_settings_helper_monitor_changed               (GFileMonitor          *monitor,
                                                                            GFile                 *file,
                                                                            GFile                 *other_file,
                                                                            GFileMonitorEvent      event_type,
                                                                            gpointer               user_data);
static void         xfce_gtk_settings_helper_channel_property_changed      (XfconfChannel         *channel,
                                                                            gchar                 *property,
                                                                            GValue                *value_unused,
                                                                            gpointer               user_data);



struct _XfceGtkSettingsHelper
{
    GObject parent;

    GHashTable *net_properties;
    XfconfChannel *channel;
    GFile *file;
    GFileMonitor *monitor;
};

static const gchar *helper_comment =
    " This comment is automatically generated by 'xfsettingsd'. Do not add your own\n"
    " comments here (i.e. above the first group in this file), they will be \n"
    " overwritten during next synchronization.\n"
    " The \"Settings\" group below is synchronized with the \"xsettings\" Xfconf\n"
    " channel by the 'xfsettingsd' daemon. Only GtkSettings properties are\n"
    " synchronized, see https://docs.gtk.org/gtk3/class.Settings.html.\n"
    " Deleting one or more properties in this file means resetting the corresponding\n"
    " properties in Xfconf. But, for safety, deleting the group itself or the file\n"
    " does not reset all the properties: the file will be rewritten from the data in\n"
    " Xfconf during next synchronization.";



G_DEFINE_TYPE (XfceGtkSettingsHelper, xfce_gtk_settings_helper, G_TYPE_OBJECT)



static void
xfce_gtk_settings_helper_class_init (XfceGtkSettingsHelperClass *klass)
{
    GObjectClass *gobject_class = G_OBJECT_CLASS (klass);

    gobject_class->finalize = xfce_gtk_settings_helper_finalize;
}



static void
xfce_gtk_settings_helper_init (XfceGtkSettingsHelper *helper)
{
    GError *error = NULL;
    gchar *path_save, *path_lookup;

    path_save = xfce_resource_save_location (XFCE_RESOURCE_CONFIG, "gtk-3.0/settings.ini", TRUE);
    if (path_save == NULL)
    {
        g_warning ("Failed to create or access GTK settings.ini parent directory");
        return;
    }

    helper->net_properties = g_hash_table_new (g_str_hash, g_str_equal);
    for (guint i = 0; i < G_N_ELEMENTS (xsettings_properties_Net); i++)
        g_hash_table_add (helper->net_properties, (gpointer) xsettings_properties_Net[i]);

    helper->channel = xfconf_channel_get ("xsettings");
    g_signal_connect (helper->channel, "property-changed", G_CALLBACK (xfce_gtk_settings_helper_channel_property_changed), helper);

    helper->file = g_file_new_for_path (path_save);
    helper->monitor = g_file_monitor_file (helper->file, G_FILE_MONITOR_WATCH_HARD_LINKS | G_FILE_MONITOR_WATCH_MOVES, NULL, &error);
    if (helper->monitor == NULL)
    {
        g_warning ("Failed to init monitoring for GTK settings.ini file: %s", error->message);
        g_clear_error (&error);
    }
    else
    {
        g_signal_connect (helper->monitor, "changed", G_CALLBACK (xfce_gtk_settings_helper_monitor_changed), helper);
    }

    /* if a system file exists but not a user file, initialize user file with system file */
    path_lookup = xfce_resource_lookup (XFCE_RESOURCE_CONFIG, "gtk-3.0/settings.ini");
    if (path_lookup != NULL && g_strcmp0 (path_lookup, path_save) != 0)
    {
        GFile *file = g_file_new_for_path (path_lookup);
        if (! g_file_copy (file, helper->file, G_FILE_COPY_NONE, NULL, NULL, NULL, &error))
        {
            g_warning ("Failed to copy GTK settings.ini file: %s", error->message);
            g_clear_error (&error);
        }
        g_object_unref (file);
    }

    /*
     * Merge GTK/Xfce sources at startup by making GTK take precedence. This is the best
     * we can do because we can't really rely on mtimes: we don't know when Xfconf writes
     * its cache on disk, synchronization might have been interrupted in one direction or
     * the other, etc.
     * In practice, this merge is quite natural for the very first synchronization, and
     * then, if the synchronization went well, the states of the two sources should be the
     * same. If not, it is more likely that there was a problem with the synchronization
     * of settings.ini to Xfconf than the other way around, or there may have been a
     * modification of this file outside of Xfce, so it seems better to preserve its
     * content first.
     * Moreover, we try to be as little destructive as possible during synchronization, in
     * both directions: things that are not part of GtkSettings are kept as much as
     * possible, especially comments in settings.ini.
     */
    xfce_gtk_settings_helper_monitor_changed (NULL, helper->file, NULL, G_FILE_MONITOR_EVENT_CHANGED, helper);
    xfce_gtk_settings_helper_channel_property_changed (helper->channel, "*", NULL, helper);

    g_free (path_save);
    g_free (path_lookup);
}



static void
xfce_gtk_settings_helper_finalize (GObject *object)
{
    XfceGtkSettingsHelper *helper = XFCE_GTK_SETTINGS_HELPER (object);

    if (helper->net_properties != NULL)
    {
        /* for simplicity we don't monitor file deletion and monitoring may have failed
         * for some reason anyway, so we just recreate the file on exit if needed */
        if (! g_file_query_exists (helper->file, NULL))
            xfce_gtk_settings_helper_channel_property_changed (helper->channel, "*", NULL, helper);

        g_signal_handlers_disconnect_by_func (helper->channel, xfce_gtk_settings_helper_channel_property_changed, helper);
        g_object_unref (helper->monitor);
        g_object_unref (helper->file);
        g_hash_table_destroy (helper->net_properties);
    }

    G_OBJECT_CLASS (xfce_gtk_settings_helper_parent_class)->finalize (object);
}



/*
 * gtk-xft-token1-token2 -> /Xft/Token1Token2
 * if Token1Token2 in xsettings_properties_Net[]: gtk-token1-token2 -> /Net/Token1Token2
 * else: gtk-token1-token2 -> /Gtk/Token1Token2
 */
static gchar *
key_to_prop (const gchar *key,
             GHashTable *net_props)
{
    gchar **tokens;
    gchar *prop, *suffix;
    gboolean xft = FALSE;

    if (! g_str_has_prefix (key, "gtk-"))
        return g_strdup (key);

    key += 4;
    if (g_str_has_prefix (key, "xft-"))
    {
        xft = TRUE;
        key += 4;
    }

    tokens = g_strsplit (key, "-", -1);
    for (gchar **token = tokens; *token != NULL; token++)
        **token = g_ascii_toupper (**token);

    suffix = g_strjoinv (NULL, tokens);
    if (xft)
      prop = g_strdup_printf ("/Xft/%s", suffix);
    else if (g_hash_table_contains (net_props, suffix))
        prop = g_strdup_printf ("/Net/%s", suffix);
    else
        prop = g_strdup_printf ("/Gtk/%s", suffix);

    g_free (suffix);
    g_strfreev (tokens);

    return prop;
}



/*
 * /Gtk/Token1Token2 -> gtk-token1-token2
 * /Net/Token1Token2 -> gtk-token1-token2
 * /Xft/Token1Token2 -> gtk-xft-token1-token2
 */
static gchar *
prop_to_key (const gchar *prop)
{
    GString *key;
    const gchar *suffix;

    suffix = g_strrstr (prop, "/");
    if (suffix == NULL)
        return g_strdup (prop);

    key = g_string_sized_new (strlen (prop));
    g_string_append (key, "gtk");
    if (g_str_has_prefix (prop, "/Xft/"))
        g_string_append (key, "-xft");

    for (const gchar *p = ++suffix; *p != '\0'; p++)
    {
        if (g_ascii_isupper (*p))
        {
            g_string_append_c (key, '-');
            g_string_append_c (key, g_ascii_tolower (*p));
        }
        else
        {
            g_string_append_c (key, *p);
        }
    }

    return g_string_free (key, FALSE);
}



static void
get_value_for_pspec (GKeyFile *key_file,
                     gchar *key,
                     GParamSpec *pspec,
                     GValue *value,
                     GError **error)
{
    GType type = G_VALUE_TYPE (g_param_spec_get_default_value (pspec));
    if (g_type_is_a (type, G_TYPE_ENUM) || g_type_is_a (type, G_TYPE_FLAGS))
        type = G_TYPE_INT;

    switch (type)
    {
        case G_TYPE_STRING:
        {
            gchar *val = g_key_file_get_string (key_file, "Settings", key, error);
            if (*error == NULL)
            {
                g_value_init (value, G_TYPE_STRING);
                g_value_set_string (value, val);
            }
            break;
        }
        case G_TYPE_BOOLEAN:
        {
            gboolean val = g_key_file_get_boolean (key_file, "Settings", key, error);
            if (*error == NULL)
            {
                g_value_init (value, G_TYPE_BOOLEAN);
                g_value_set_boolean (value, val);
            }
            break;
        }
        case G_TYPE_INT:
        case G_TYPE_UINT:
        case G_TYPE_LONG:
        case G_TYPE_ULONG:
        case G_TYPE_ENUM:
        case G_TYPE_FLAGS:
        {
            gint val = g_key_file_get_integer (key_file, "Settings", key, error);
            if (*error == NULL)
            {
                g_value_init (value, G_TYPE_INT);
                g_value_set_int (value, val);
            }
            break;
        }
        case G_TYPE_INT64:
        {
            gint64 val = g_key_file_get_int64(key_file, "Settings", key, error);
            if (*error == NULL)
            {
                g_value_init (value, G_TYPE_INT64);
                g_value_set_int64(value, val);
            }
            break;
        }
        case G_TYPE_UINT64:
        {
            guint64 val = g_key_file_get_uint64(key_file, "Settings", key, error);
            if (*error == NULL)
            {
                g_value_init (value, G_TYPE_UINT64);
                g_value_set_uint64(value, val);
            }
            break;
        }
        case G_TYPE_FLOAT:
        case G_TYPE_DOUBLE:
        {
            gdouble val = g_key_file_get_double (key_file, "Settings", key, error);
            if (*error == NULL)
            {
                g_value_init (value, G_TYPE_DOUBLE);
                g_value_set_double (value, val);
            }
            break;
        }
        default:
            /* in particular, GKeyFile is able to handle "lists" of string, boolean, etc.
             * but there is none in GtkSettings currently */
            g_set_error (error, G_KEY_FILE_ERROR, G_KEY_FILE_ERROR_INVALID_VALUE, "Unsupported type '%s'", g_type_name (type));
            break;
    }
}



static void
set_value_for_pspec (GKeyFile *key_file,
                     gchar *key,
                     GValue *value,
                     GParamSpec *pspec)
{
    GType type = G_VALUE_TYPE (value);
    GType type_pspec = G_VALUE_TYPE (g_param_spec_get_default_value (pspec));
    if (! g_value_type_transformable (type, type_pspec))
    {
        g_warning ("Failed to set value for key '%s': Type '%s' is not compatible with type '%s' of GtkSettings property '%s'",
                   key, g_type_name (type), g_type_name (type_pspec), g_param_spec_get_name (pspec));
        return;
    }

    switch (type)
    {
        case G_TYPE_STRING:
            g_key_file_set_string (key_file, "Settings", key, g_value_get_string (value));
            break;

        case G_TYPE_BOOLEAN:
            g_key_file_set_boolean (key_file, "Settings", key, g_value_get_boolean (value));
            break;

        case G_TYPE_INT:
        case G_TYPE_UINT:
        case G_TYPE_LONG:
        case G_TYPE_ULONG:
        case G_TYPE_ENUM:
        case G_TYPE_FLAGS:
        {
            GValue value_trans = G_VALUE_INIT;
            g_value_init (&value_trans, G_TYPE_INT);
            g_value_transform (value, &value_trans);
            g_key_file_set_integer (key_file, "Settings", key, g_value_get_int (&value_trans));
            g_value_unset (&value_trans);
            break;
        }
        case G_TYPE_INT64:
            g_key_file_set_int64 (key_file, "Settings", key, g_value_get_int64 (value));
            break;

        case G_TYPE_UINT64:
            g_key_file_set_uint64 (key_file, "Settings", key, g_value_get_uint64 (value));
            break;

        case G_TYPE_FLOAT:
        case G_TYPE_DOUBLE:
        {
            GValue value_trans = G_VALUE_INIT;
            g_value_init (&value_trans, G_TYPE_DOUBLE);
            g_value_transform (value, &value_trans);
            g_key_file_set_double (key_file, "Settings", key, g_value_get_double (&value_trans));
            g_value_unset (&value_trans);
            break;
        }
        default:
            /* see corresponding comment in get_value_for_pspec() */
            g_warning ("Failed to set value for key '%s': Unsupported type '%s'", key, g_type_name (type));
            break;
    }
}



static void
xfce_gtk_settings_helper_monitor_changed (GFileMonitor *monitor,
                                          GFile *file,
                                          GFile *other_file,
                                          GFileMonitorEvent event_type,
                                          gpointer user_data)
{
    XfceGtkSettingsHelper *helper = user_data;
    GtkSettings *settings;
    GError *error = NULL;
    GKeyFile *key_file;
    GHashTable *props;
    GHashTableIter iter;
    gchar **keys;
    GParamSpec *pspec;
    GValue value = G_VALUE_INIT;
    gchar *prop, *key;

    /* we are only interested in changed events in the broadest sense */
    if (event_type != G_FILE_MONITOR_EVENT_CHANGES_DONE_HINT
        && event_type != G_FILE_MONITOR_EVENT_CHANGED
        && event_type != G_FILE_MONITOR_EVENT_CREATED
        && event_type != G_FILE_MONITOR_EVENT_MOVED_IN
        && (event_type != G_FILE_MONITOR_EVENT_RENAMED || ! g_file_equal (helper->file, other_file)))
        return;

    settings = gtk_settings_get_default ();
    if (settings == NULL)
    {
        g_warning ("Failed to get GtkSettings instance");
        return;
    }

    key_file = g_key_file_new ();
    if (! g_key_file_load_from_file (key_file, g_file_peek_path (helper->file), G_KEY_FILE_NONE, &error)
        || (keys = g_key_file_get_keys (key_file, "Settings", NULL, &error)) == NULL)
    {
        if (error->domain == G_FILE_ERROR || g_error_matches (error, G_KEY_FILE_ERROR, G_KEY_FILE_ERROR_GROUP_NOT_FOUND))
        {
            /* don't warn about non existent file or missing "Settings" group, however leave:
             * for safety we don't consider this as a general reset, and we document this
             * behavior when writing settings.ini */
            if (! g_error_matches (error, G_FILE_ERROR, G_FILE_ERROR_NOENT)
                && ! g_error_matches (error, G_KEY_FILE_ERROR, G_KEY_FILE_ERROR_GROUP_NOT_FOUND))
                g_warning ("Failed to load GTK settings.ini file: %s", error->message);

            g_error_free (error);
            g_key_file_free (key_file);
            return;
        }
        else
        {
            g_clear_error (&error);
        }
    }

    /* avoid cycling */
    g_signal_handlers_block_by_func (helper->channel, xfce_gtk_settings_helper_channel_property_changed, helper);

    /* update/add Xfconf properties (keys updated/added to file) */
    props = xfconf_channel_get_properties (helper->channel, NULL);
    for (gchar **pkey = keys; *pkey != NULL; pkey++)
    {
        /* silently skip keys that are not in GtkSettings */
        pspec = g_object_class_find_property (G_OBJECT_GET_CLASS (settings), *pkey);
        if (pspec == NULL)
            continue;

        prop = key_to_prop (*pkey, helper->net_properties);
        get_value_for_pspec (key_file, *pkey, pspec, &value, &error);
        if (G_VALUE_TYPE (&value) != G_TYPE_INVALID)
        {
            if (! xfconf_channel_set_property (helper->channel, prop, &value))
                g_warning ("Failed to set property '%s'", prop);
            g_value_unset (&value);
        }
        else
        {
            g_warning ("Failed to get value for key '%s': %s", *pkey, error->message);
            g_clear_error (&error);
        }

        g_hash_table_remove (props, prop);
        g_free (prop);
    }

    /* reset remaining Xfconf properties (keys removed from file) unless we merge */
    if (monitor != NULL)
    {
        g_hash_table_iter_init (&iter, props);
        while (g_hash_table_iter_next (&iter, (gpointer *) &prop, NULL))
        {
            key = prop_to_key (prop);

            /* silently skip keys that are not in GtkSettings */
            pspec = g_object_class_find_property (G_OBJECT_GET_CLASS (settings), key);
            g_free (key);
            if (pspec == NULL)
                continue;

            xfconf_channel_reset_property (helper->channel, prop, FALSE);
        }
    }

    g_signal_handlers_unblock_by_func (helper->channel, xfce_gtk_settings_helper_channel_property_changed, helper);

    g_hash_table_destroy (props);
    g_strfreev (keys);
    g_key_file_free (key_file);
}



static void
xfce_gtk_settings_helper_channel_property_changed (XfconfChannel *channel,
                                                   gchar *property,
                                                   GValue *value_unused,
                                                   gpointer user_data)
{
    XfceGtkSettingsHelper *helper = user_data;
    GtkSettings *settings;
    GError *error = NULL;
    GKeyFile *key_file;
    GHashTable *props;
    GHashTableIter iter;
    gchar **keys;
    GParamSpec *pspec;
    GValue *value;
    gchar *prop, *key;

    settings = gtk_settings_get_default ();
    if (settings == NULL)
    {
        g_warning ("Failed to get GtkSettings instance");
        return;
    }

    /* for simplicity we don't monitor file deletion and monitoring may have failed for
     * some reason anyway, so we just rewrite the whole file on each property change */
    key_file = g_key_file_new ();
    if (! g_key_file_load_from_file (key_file, g_file_peek_path (helper->file), G_KEY_FILE_KEEP_COMMENTS, &error))
    {
        if (error->domain == G_FILE_ERROR && ! g_error_matches (error, G_FILE_ERROR, G_FILE_ERROR_NOENT))
        {
            g_warning ("Failed to load GTK settings.ini file: %s", error->message);
            g_error_free (error);
            g_key_file_free (key_file);
            return;
        }
        else
        {
            g_clear_error (&error);
        }
    }

    /* remove keys that are not in Xfconf */
    keys = g_key_file_get_keys (key_file, "Settings", NULL, NULL);
    props = xfconf_channel_get_properties (helper->channel, NULL);
    if (keys != NULL)
    {
        for (gchar **pkey = keys; *pkey != NULL; pkey++)
        {
            /* silently skip keys that are not in GtkSettings */
            pspec = g_object_class_find_property (G_OBJECT_GET_CLASS (settings), *pkey);
            if (pspec == NULL)
                continue;

            prop = key_to_prop (*pkey, helper->net_properties);
            if (! g_hash_table_contains (props, prop)
                && ! g_key_file_remove_key (key_file, "Settings", *pkey, &error))
            {
                g_warning ("Failed to remove key '%s' from GTK settings.ini file: %s", *pkey, error->message);
                g_clear_error (&error);
            }
            g_free (prop);
        }
        g_strfreev (keys);
    }

    /* update/add keys (properties updated/added to Xfconf) */
    g_hash_table_iter_init (&iter, props);
    while (g_hash_table_iter_next (&iter, (gpointer *) &prop, (gpointer *) &value))
    {
        key = prop_to_key (prop);

        /* silently skip keys that are not in GtkSettings */
        pspec = g_object_class_find_property (G_OBJECT_GET_CLASS (settings), key);
        if (pspec == NULL)
        {
            g_free (key);
            continue;
        }

        set_value_for_pspec (key_file, key, value, pspec);
        g_free (key);
    }

    /*
     * Add our comment: we can't add it above the "Settings" group because the API is buggy
     * in this case: see https://gitlab.gnome.org/GNOME/glib/-/issues/104.
     * So we add it at the beginning of the file, warning the user not to add his own
     * comments here, because we do a remove/add each time for simplicity.
     */
    g_key_file_remove_comment (key_file, NULL, NULL, NULL);
    if (! g_key_file_set_comment (key_file, NULL, NULL, helper_comment, &error))
    {
        g_warning ("Failed to add helper comment to GTK settings.ini file: %s", error->message);
        g_clear_error (&error);
    }

    /* avoid cycling if possible: it will probably trigger monitor_changed() despite the
     * blocking because it happens after a certain delay, but the cycle will stop there,
     * so better not to complicate the code unnecessarily */
    if (helper->monitor != NULL)
        g_signal_handlers_block_by_func (helper->monitor, xfce_gtk_settings_helper_monitor_changed, helper);
    if (! g_key_file_save_to_file (key_file, g_file_peek_path (helper->file), &error))
    {
        g_warning ("Failed to save GTK settings.ini file: %s", error->message);
        g_error_free (error);
    }
    if (helper->monitor != NULL)
        g_signal_handlers_unblock_by_func (helper->monitor, xfce_gtk_settings_helper_monitor_changed, helper);

    g_hash_table_destroy (props);
    g_key_file_free (key_file);
}
